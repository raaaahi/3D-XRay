# -*- coding: utf-8 -*-
"""CTtoDXR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MtszescDAmQpvkGmoKSPNPGd_uWL8AH-
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install numpy matplotlib scipy tqdm SimpleITK scikit-image astra-toolbox
# %pip install pydicom

# Cell 1: Setup and Imports
from google.colab import drive
drive.mount('/content/drive')

#TODO
# get the actual slice and dimenstions from the default tiff folder

# HD Projection Generator - Standard Images Only (512x512x68)
import numpy as np
import pydicom
import matplotlib.pyplot as plt
from scipy import ndimage
from scipy.ndimage import affine_transform, gaussian_filter, correlate
from skimage.transform import resize
from tqdm.notebook import tqdm
import gc
import os
import time

# Configurable parameters - modified as needed
INPUT_PATH = "/content/drive/MyDrive/Biorobotics II /set1"  # Path to DICOM files
OUTPUT_PATH = "/content/drive/MyDrive/Biorobotics II /scripts/generatedDXRs"  # Output directory

TARGET_DIMS = np.array([512, 512, 68])  # Modified resolution to match request
ORIGINAL_DIMS = np.array([512, 512, 68])  # Original dimensions of the DICOM series

# Utility functions
def normalize_volume(volume):
    """Normalize volume safely using vector operations"""
    vol_min = np.min(volume)
    vol_max = np.max(volume)

    # Handle case where min=max (constant volume)
    if vol_max == vol_min:
        return np.zeros_like(volume)  # Return zeros if volume is constant
    else:
        return (volume - vol_min) / (vol_max - vol_min)

def rotate_volume(volume, angle_deg):
    """Rotate the volume around vertical axis (z-axis)"""
    # Create padded volume to prevent data loss during rotation
    pad_width = int(volume.shape[0] * 0.5)  # Larger padding for safety
    padded = np.pad(volume, ((pad_width, pad_width),
                           (pad_width, pad_width),
                           (pad_width, pad_width)),
                 mode='constant', constant_values=0)

    # Rotate volume around z-axis
    rotated = ndimage.rotate(padded, angle_deg, axes=(1, 0), reshape=False, order=1)

    # Crop back to original size (from center)
    center = np.array(rotated.shape) // 2
    start = center - np.array(volume.shape) // 2
    end = start + np.array(volume.shape)
    cropped = rotated[start[0]:end[0], start[1]:end[1], start[2]:end[2]]

    return cropped

def project_volume_orthogonal(volume, angle_deg):
    """
    Rotate volume first, then project orthogonally along y-axis,
    expand columns 1-70 to fill 128 columns
    """
    # Rotate the volume around vertical axis
    rotated_volume = rotate_volume(volume, angle_deg)

    # Project along y-axis (front-to-back)
    projection = np.sum(rotated_volume, axis=1)

    # Get the shape of the initial projection
    proj_height, proj_width = projection.shape

    # First, extract the content from columns 0-70 (or as many as available)
    max_cols = min(350, proj_width)  # Adjusted for higher resolution (512 instead of 128)
    content_columns = projection[:, :max_cols]

    # Create a target array for the expanded columns (512 wide)
    expanded_proj = np.zeros((proj_height, 512))

    # Calculate expansion factor to go from max_cols to 512
    expansion_factor = 512 / max_cols

    # For each column in the source, calculate its position(s) in the target
    for src_col in range(max_cols):
        # Calculate target column positions
        target_start = int(src_col * expansion_factor)
        target_end = int((src_col + 1) * expansion_factor)

        # Ensure we don't go out of bounds
        target_end = min(target_end, 512)

        # Copy the source column to all corresponding target columns
        if target_start < target_end:  # Ensure we're not trying to put content in an empty range
            for target_col in range(target_start, target_end):
                expanded_proj[:, target_col] = content_columns[:, src_col]

    # Normalize the expanded projection
    if expanded_proj.max() > expanded_proj.min():
        expanded_proj = (expanded_proj - expanded_proj.min()) / (expanded_proj.max() - expanded_proj.min())

    return expanded_proj

def load_and_compress_dicoms():
    """Load DICOM files and keep original dimensions (no compression)"""
    # Since TARGET_DIMS now equals ORIGINAL_DIMS, we're not compressing but preserving dimensions
    volume = np.zeros(TARGET_DIMS)

    for slice_num in tqdm(range(1, np.take(ORIGINAL_DIMS, -1) + 1), desc="Loading DICOM files"):
        filename = f'{INPUT_PATH}/1-{slice_num:02d}.dcm'
        try:
            ds = pydicom.dcmread(filename)
            # Get raw slice data and store directly (no resizing needed)
            volume[:, :, slice_num-1] = ds.pixel_array
        except Exception as e:
            print(f'Error loading slice {slice_num}: {e}')

    # Preprocess: Rotate the entire volume 90 degrees clockwise around the z-axis
    volume = ndimage.rotate(volume, angle=-90, axes=(1, 0), reshape=False, order=1)

    return normalize_volume(volume)

def generate_hd_projections(volume, angle_step=1):
    """
    Generate high-resolution projections at specified angular resolution
    (standard projections only)
    """
    # Create a range of angles from 0 to 359 with step size of angle_step
    angles = np.arange(0, 360, angle_step)

    print(f"Generating HD projections at {len(angles)} angles ({angle_step}° intervals)...")

    # Generate standard projections at highest resolution
    standard_projections = []

    for angle in tqdm(angles, desc="Generating HD projections"):
        # Generate standard projection with maximum resolution
        standard_proj = project_volume_orthogonal(volume, angle)
        standard_projections.append(standard_proj)

    # Convert to numpy array
    standard_projections = np.array(standard_projections)

    return angles, standard_projections

def save_hd_projection_datasets(angles, standard_projections, output_path):
    """
    Save high-resolution projection datasets to disk
    (standard projections only)
    """
    # Create directories if they don't exist
    dataset_dir = output_path
    standard_dir = os.path.join(dataset_dir, 'standard_dxr')

    # Create directories
    os.makedirs(dataset_dir, exist_ok=True)
    os.makedirs(standard_dir, exist_ok=True)

    print(f"Saving HD datasets to {dataset_dir}...")

    # Save angles array
    np.save(os.path.join(dataset_dir, 'angles.npy'), angles)

    # Save standard projections
    for i, angle in enumerate(tqdm(angles, desc="Saving standard HD projections")):
        # Save as numpy array (individual files)
        np.save(os.path.join(standard_dir, f'projection_{angle:.1f}.npy'), standard_projections[i])

        # Save PNG images every 5 degrees for visualization
        if angle % 5 == 0:
            plt.figure(figsize=(10, 10), dpi=150)
            plt.imshow(standard_projections[i], cmap='gray')
            plt.title(f'HD Standard DXR - {angle}°')
            plt.axis('off')
            plt.tight_layout()
            plt.savefig(os.path.join(standard_dir, f'projection_{angle:.1f}.png'), dpi=150, bbox_inches='tight')
            plt.close()

    # Save the complete dataset as a single file
    np.save(os.path.join(dataset_dir, 'standard_projections.npy'), standard_projections)

    print(f"Saved {len(angles)} HD projections.")
    print(f"Standard projections shape: {standard_projections.shape}")

    # Create a simple README file with dataset information
    with open(os.path.join(dataset_dir, 'README.txt'), 'w') as f:
        f.write(f"HD DXR Projection Datasets (Standard Only)\n")
        f.write(f"=======================================\n\n")
        f.write(f"Generated on: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Angular step: {angles[1]-angles[0]} degrees\n")
        f.write(f"Number of projections: {len(angles)}\n")
        f.write(f"Projection dimensions: {standard_projections[0].shape}\n\n")
        f.write(f"Contents:\n")
        f.write(f"- angles.npy: Array of projection angles\n")
        f.write(f"- standard_projections.npy: Complete array of HD standard projections\n")
        f.write(f"- standard_dxr/: Directory containing individual standard HD projections\n")
        f.write(f"- PNG images are saved every 5 degrees (0°, 5°, 10°, etc.)\n")

    return dataset_dir

def verify_hd_projections(standard_projections):
    """
    Display sample projections to verify quality and resolution
    (standard projections only)
    """
    # Choose key angles to display
    key_angles = [0, 45, 90, 135, 180, 225, 270, 315]

    # Calculate projection dimensions and details
    num_projs, height, width = standard_projections.shape

    print(f"Projection verification:")
    print(f"  Total projections: {num_projs}")
    print(f"  Dimensions: {height}x{width} pixels")
    print(f"  Min value: {standard_projections.min():.4f}")
    print(f"  Max value: {standard_projections.max():.4f}")
    print(f"  Mean value: {standard_projections.mean():.4f}")

    # Plot standard projections at key angles
    plt.figure(figsize=(20, 10))
    plt.suptitle("Standard DXR Projections - Verification", fontsize=16)

    for i, angle_idx in enumerate(key_angles):
        if angle_idx < num_projs:
            plt.subplot(2, 4, i+1)
            plt.imshow(standard_projections[angle_idx], cmap='gray')
            plt.title(f'Standard - {angle_idx}°')
            plt.axis('off')

    plt.tight_layout()
    plt.subplots_adjust(top=0.9)
    plt.show()

def main():
    """
    Main function to load volume, generate HD projections, verify, and save
    """
    # Start timing
    start_time = time.time()

    print("Starting HD projection generation process...")
    print(f"Input DICOM path: {INPUT_PATH}")
    print(f"Output dataset path: {OUTPUT_PATH}")
    print(f"Target dimensions: {TARGET_DIMS}")

    # Load the CT volume
    print("Loading DICOM data...")
    volume = load_and_compress_dicoms()

    # Generate projections at 1-degree intervals
    angles, standard_projections = generate_hd_projections(volume, angle_step=10)   #parameter for the projections

    # Verify projections by displaying samples
    verify_hd_projections(standard_projections)

    # Save the datasets
    dataset_dir = save_hd_projection_datasets(angles, standard_projections, OUTPUT_PATH)

    # Report total time
    elapsed_time = time.time() - start_time
    print(f"Total time: {elapsed_time:.2f} seconds")
    print(f"HD Datasets saved to: {dataset_dir}")

    return dataset_dir, standard_projections

# Run the main function if script is executed directly
if __name__ == "__main__":
    main()