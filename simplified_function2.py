# -*- coding: utf-8 -*-
"""simplified_function.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11HnE7wAOybeiPSlVN0v9cNwQGhHv4gqv
"""

# Commented out IPython magic to ensure Python compatibility.
import heapq

from google.colab import drive
drive.mount('/content/drive/')
# %cd /content/drive/MyDrive/Biorobotics II /scripts/
# %ls

import anglesToImgQualityDEBUG #this is the script!
import anglesToImgQuality #this is the same script, but runs faster but no debug outputs

def a_s(tar_rmse=0.12, max_angles=360, angle_step=5):
    # Priority queue to store states
    open_set = []
    # Track explored angle combinations
    closed_set = set()

    # Initial state (no angles selected)
    initial_state = []

    # Heuristic function to estimate state cost
    def calculate_state_cost(angles):
        # If no angles, return a high cost
        if not angles:
            return float('inf')

        # Calculate mean error
        try:
            mean_error, _ = anglesToImgQuality.anglesToImgQuality(angles)
        except Exception:
            # Handle potential errors in reconstruction
            mean_error = float('inf')

        # Calculate completeness
        completeness = anglesToCompleteness(angles)

        # Combined cost function
        # Lower is better
        # Penalize high error and low completeness
        cost = (
            mean_error / (completeness + 0.001)  # Avoid division by zero
        )

        return cost

    # Initial push with empty state
    # heapq.heappush(open_set, (0, initial_state))
    heapq.heappush(open_set, (0, [0]))  # Start with 0-degree angle



    # Track best solution
    best_solution = {
        'angles': [],
        'mean_error': float('inf'),
        'completeness': 0
    }

    # Iteration limit to prevent infinite search
    max_iterations = 1000
    iterations = 0

    while open_set and iterations < max_iterations:
        iterations += 1

        # Get the state with lowest estimated cost
        current_cost, current_angles = heapq.heappop(open_set)

        # Avoid revisiting same angle combinations
        angles_tuple = tuple(sorted(current_angles))
        if angles_tuple in closed_set:
            continue
        closed_set.add(angles_tuple)

        # Evaluate current state
        try:
            mean_error, _ = anglesToImgQuality.anglesToImgQuality(current_angles)
            completeness = anglesToCompleteness(current_angles)
        except Exception:
            continue

        # Update best solution if current is better
        if (mean_error < best_solution['mean_error'] and
            completeness > best_solution['completeness']):
            best_solution = {
                'angles': current_angles,
                'mean_error': mean_error,
                'completeness': completeness
            }

        # Stop if we've met our target
        if mean_error <= tar_rmse and completeness >= 0.9:
            break

        # Explore new angles
        for new_angle in range(0, max_angles, angle_step):
            # Skip if angle already in current set
            if new_angle in current_angles:
                continue

            # Create new state by adding angle
            new_angles = current_angles + [new_angle]

            # Calculate cost for new state
            new_cost = calculate_state_cost(new_angles)

            # Push to priority queue
            heapq.heappush(open_set, (new_cost, new_angles))

    # Print and return results
    print("Best Angles:", best_solution['angles'])
    print("Mean Error:", best_solution['mean_error'])
    print("Completeness:", best_solution['completeness'])

    return best_solution

result = a_s(tar_rmse=0.50)

def anglesToCompleteness(test_angles, max_angles=360): #where a value of 1 is perfect reconstruction at 360, 0.5 is a reconstruction of
    basic_completeness = len(test_angles) / max_angles
    if len(test_angles) == 0:
        return 0.0
    sorted_angles = sorted(test_angles)
    full_circle = sorted_angles + [sorted_angles[0] + max_angles]

    gaps = [full_circle[i+1] - full_circle[i] for i in range(len(full_circle)-1)]
    max_gap = max(gaps)

    ideal_gap = max_angles / len(test_angles)
    gap_penalty = min(1.0, ideal_gap / max_gap)

    # Combine basic completeness with gap penalty
    # This rewards both using more angles and distributing them evenly
    adjusted_completeness = basic_completeness * gap_penalty

    return adjusted_completeness

#call the function
#a_s(0.5)
# a_s(0.12)
# Example usage
result = a_s(tar_rmse=0.01)
#test_angles = ??

print (result(1))

#modify "the paramter in the function is a list, for our purposes, this is a list that updates as the specific angles change,
#test_angles = list(range(0, 360, 90))  # Use every X degrees
#debugging area

solvedAngles = [0, 180, 195, 200, 30, 220, 190, 170, 10, 215, 185, 40, 245, 135, 280, 100, 320, 80, 165, 5, 35, 330, 210, 60, 295, 340, 120, 270, 145, 235, 75, 255, 305, 90, 275, 105, 335, 300, 25, 350, 325, 175, 355, 240, 65, 155, 50, 115, 310, 70, 160, 225, 45, 250, 315, 285, 110, 20, 55, 95, 345, 130, 260, 140, 265, 15, 230, 85, 125, 290
]


# test_angles = list(range(0, 355, 5))  # Use every C degrees between A and B
test_angles  = solvedAngles


mean_error, std_error = anglesToImgQualityDEBUG.anglesToImgQuality(test_angles)  #can be suppressed to remove text outputs, rn for debugging
print(f"Test Results: Mean Error = {mean_error:.4f}, Std Error = {std_error:.4f}")

completeness = anglesToCompleteness(test_angles)
print(f"Test Results: Completeness = {completeness:.4f}")

#modify "the paramter in the function is a list, for our purposes, this is a list that updates as the specific angles change,
#test_angles = list(range(0, 360, 90))  # Use every X degrees
#debugging area

solvedAngles = [0, 180, 195, 200, 30, 220, 190, 170, 10, 215, 185, 40, 245, 135, 280, 100, 320, 80, 165, 5, 35, 330, 210, 60, 295, 340, 120, 270, 145, 235, 75, 255, 305, 90, 275, 105, 335, 300, 25, 350, 325, 175, 355, 240, 65, 155, 50, 115, 310, 70, 160, 225, 45, 250, 315, 285, 110, 20, 55, 95, 345, 130, 260, 140, 265, 15, 230, 85, 125, 290
]


# test_angles = list(range(0, 355, 5))  # Use every C degrees between A and B
test_angles  = solvedAngles


mean_error, std_error = anglesToImgQuality.anglesToImgQuality(test_angles)  #can be suppressed to remove text outputs, rn for debugging
print(f"Test Results: Mean Error = {mean_error:.4f}, Std Error = {std_error:.4f}")

completeness = anglesToCompleteness(test_angles)
print(f"Test Results: Completeness = {completeness:.4f}")