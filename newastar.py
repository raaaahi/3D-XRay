# -*- coding: utf-8 -*-
"""newAstar.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ej7bBnrBN8PtDkHBbYI7G15IZ3STYV4L
"""

# Commented out IPython magic to ensure Python compatibility.
import heapq

from google.colab import drive
drive.mount('/content/drive/')
# %cd /content/drive/MyDrive/Biorobotics II /scripts/
# %ls

import anglesToImgQualityDEBUG #this is the script!
import anglesToImgQuality #this is the same script, but runs faster but no debug outputs

def a_star(target_rmse=0.12, max_angles=360, angle_step=5, max_iterations=1000):
    """
    A* algorithm to find optimal angles for CT reconstruction.

    Args:
        target_rmse: Target RMSE to achieve
        max_angles: Maximum angle value (typically 360)
        angle_step: Step size between angles to consider
        max_iterations: Maximum iterations to prevent infinite search

    Returns:
        dict: Best solution found with angles, mean_error, and completeness
    """
    # Priority queue to store states: (f_score, state_id, g_score, angles)
    # f_score = g_score + h_score (estimated total cost)
    # g_score = cost so far (number of angles used)
    # angles = tuple of angles selected so far
    open_set = []

    # Track explored angle combinations and their g_scores
    closed_set = {}  # {angles_tuple: g_score}

    # Initial state (start with angle 0)
    initial_angles = (0,90,270)
    initial_g_score = 1  # Cost of using one angle

    # Evaluate initial state
    initial_mean_error, _ = anglesToImgQuality.anglesToImgQuality(initial_angles)
    initial_completeness = anglesToCompleteness(initial_angles, max_angles)

    # Calculate initial h_score (heuristic) - estimated additional angles needed
    initial_h_score = estimate_remaining_angles(initial_mean_error, target_rmse, initial_completeness)

    # Calculate initial f_score
    initial_f_score = initial_g_score + initial_h_score

    # Track best solution found so far
    best_solution = {
        'angles': list(initial_angles),
        'mean_error': initial_mean_error,
        'completeness': initial_completeness,
        'f_score': initial_f_score
    }

    # Add initial state to open set
    # We use state_id to break ties when f_scores are equal
    state_id = 0
    heapq.heappush(open_set, (initial_f_score, state_id, initial_g_score, initial_angles))

    # Track parent states for path reconstruction
    parents = {}  # {child_angles: parent_angles}

    iterations = 0

    while open_set and iterations < max_iterations:
        iterations += 1

        # Get state with lowest f_score
        f_score, _, g_score, current_angles = heapq.heappop(open_set)

        # Check if we've found a better solution
        try:
            mean_error, _ = anglesToImgQuality.anglesToImgQuality(current_angles)
            completeness = anglesToCompleteness(current_angles, max_angles)

            # Update best solution if current is better (weighted combined metric)
            current_quality = calculate_solution_quality(mean_error, target_rmse, completeness)
            best_quality = calculate_solution_quality(best_solution['mean_error'], target_rmse, best_solution['completeness'])

            if current_quality > best_quality:
                best_solution = {
                    'angles': list(current_angles),
                    'mean_error': mean_error,
                    'completeness': completeness,
                    'f_score': f_score
                }

                print(f"Iteration {iterations}: Found better solution with {len(current_angles)} angles")
                print(f"  Mean Error: {mean_error:.4f}, Completeness: {completeness:.4f}")
        except Exception as e:
            print(f"Error evaluating angles {current_angles}: {e}")
            continue

        # Check if we've reached the goal
        if mean_error <= target_rmse and completeness >= 0.9:
            print(f"Goal reached after {iterations} iterations!")
            # Reconstruct path is unnecessary as we already have the angles
            return best_solution

        # If we've already found a better path to this state, skip expansion
        if current_angles in closed_set and closed_set[current_angles] <= g_score:
            continue

        # Add current state to closed set
        closed_set[current_angles] = g_score

        # Expand current state (generate successor states)
        for new_angle in range(0, max_angles, angle_step):
            # Skip if angle already in current set
            if new_angle in current_angles:
                continue

            # Create new state by adding angle
            # Sort to ensure we can check for duplicate states properly
            new_angles = tuple(sorted(current_angles + (new_angle,)))

            # Calculate new g_score (cost so far)
            new_g_score = len(new_angles)  # Cost is number of angles

            # Skip if we've already found a better path to this state
            if new_angles in closed_set and closed_set[new_angles] <= new_g_score:
                continue

            # Calculate new state metrics
            try:
                new_mean_error, _ = anglesToImgQuality.anglesToImgQuality(new_angles)
                new_completeness = anglesToCompleteness(new_angles, max_angles)

                try:
                  new_mean_error, _ = anglesToImgQuality.anglesToImgQuality(new_angles)
                  new_completeness = anglesToCompleteness(new_angles, max_angles)

                  # Early pruning check - ADD THIS CODE
                  if is_unpromising_state(new_angles, new_mean_error, new_completeness, best_solution, target_rmse):
                      continue  # Skip this state if it's unpromising

                  # Calculate heuristic (h_score)
                  new_h_score = estimate_remaining_angles(new_mean_error, target_rmse, new_completeness)

                  # Calculate f_score
                  new_f_score = new_g_score + new_h_score

                  # Add to open set
                  state_id += 1
                  heapq.heappush(open_set, (new_f_score, state_id, new_g_score, new_angles))

                  # Track parent for path reconstruction
                  parents[new_angles] = current_angles
                except Exception as e:
                  print(f"Error evaluating new angles {new_angles}: {e}")
                  continue


                # Calculate heuristic (h_score)
                new_h_score = estimate_remaining_angles(new_mean_error, target_rmse, new_completeness)

                # Calculate f_score
                new_f_score = new_g_score + new_h_score

                # Add to open set
                state_id += 1
                heapq.heappush(open_set, (new_f_score, state_id, new_g_score, new_angles))

                # Track parent for path reconstruction
                parents[new_angles] = current_angles
            except Exception as e:
                print(f"Error evaluating new angles {new_angles}: {e}")
                continue

    print(f"Search completed after {iterations} iterations")
    return best_solution

def estimate_remaining_angles(current_error, target_error, current_completeness):
    """
    Heuristic function: Estimates additional angles needed to reach target.
    This is an admissible heuristic that never overestimates true cost.

    Args:
        current_error: Current RMSE
        target_error: Target RMSE
        current_completeness: Current coverage completeness (0-1)

    Returns:
        float: Estimated additional angles needed
    """
    # Estimate based on the difference between current and target error
    if current_error <= target_error:
        error_factor = 0
    else:
        # Error ratio (how far we are from target)
        error_ratio = (current_error - target_error) / current_error
        error_factor = error_ratio * 10  # Scale factor

    # Estimate based on incompleteness
    completeness_factor = max(0, (0.9 - current_completeness) * 10)

    # Combine factors (use minimum to ensure admissibility)
    return min(error_factor, completeness_factor)




def calculate_solution_quality(error, target_error, completeness):
    """
    Calculate solution quality using a weighted combination of error and completeness.
    Higher values are better.

    Args:
        error: RMSE error of the solution
        target_error: Target RMSE
        completeness: Coverage completeness (0-1)

    Returns:
        float: Quality score (higher is better)
    """
    # Error component (1.0 when error equals target, declines as error increases)
    if error <= target_error:
        error_quality = 1.0
    else:
        error_quality = target_error / error  # Inverse relationship

    # Completeness component (linear)
    completeness_quality = completeness

    # Combined quality (weighted average)
    return (error_quality * 0.8) + (completeness_quality * 0.2)



def is_unpromising_state(angles, error, completeness, best_solution, target_rmse):
    """
    Determine if a state is unlikely to lead to an optimal solution.

    Args:
        angles: Tuple of selected angles
        error: Current RMSE error
        completeness: Current completeness score
        best_solution: Current best solution found
        target_rmse: Target RMSE to achieve

    Returns:
        bool: True if the state is unpromising and should be pruned
    """
    # 1. If we already have a solution with better error AND better completeness
    if (error > best_solution['mean_error'] and
        completeness < best_solution['completeness']):
        return True

    # 2. If we have too many angles but still poor quality
    if (len(angles) > len(best_solution['angles']) * 1.5 and
        error > best_solution['mean_error']):
        return True

    # 3. Check for poor angle distribution
    sorted_angles = sorted(angles)
    full_circle = sorted_angles + [sorted_angles[0] + 360]
    gaps = [full_circle[i+1] - full_circle[i] for i in range(len(full_circle)-1)]

    # If there's a very large gap (e.g., more than 120 degrees) and we have many angles
    if max(gaps) > 120 and len(angles) > 5:
        return True

    # 4. If we have many angles but error still far from target
    if len(angles) > 10 and error > target_rmse * 2:
        return True

    # 5. If adding more angles isn't improving completeness effectively
    if len(angles) > 6 and completeness < 0.2:
        return True

    print("pruned \n")
    return False


def anglesToCompleteness(test_angles, max_angles=360):
    """
    Calculate the completeness of angle coverage.

    Args:
        test_angles: List or tuple of angles used
        max_angles: Maximum angle value (typically 360)

    Returns:
        float: Completeness score (0-1)
    """
    if len(test_angles) == 0:
        return 0.0

    # Basic completeness based on number of angles
    basic_completeness = len(test_angles) / max_angles

    # Calculate gap distribution uniformity
    sorted_angles = sorted(test_angles)
    full_circle = sorted_angles + [sorted_angles[0] + max_angles]

    gaps = [full_circle[i+1] - full_circle[i] for i in range(len(full_circle)-1)]
    max_gap = max(gaps)

    ideal_gap = max_angles / len(test_angles)
    gap_penalty = min(1.0, ideal_gap / max_gap)

    # Combine basic completeness with gap penalty
    adjusted_completeness = basic_completeness * gap_penalty

    return adjusted_completeness

if __name__ == "__main__":
    # Example usage
    result = a_star(target_rmse=0.45, angle_step=5, max_iterations=1000)
    print("\nFinal result:")
    print(f"Angles: {result['angles']}")
    print(f"Mean Error: {result['mean_error']:.4f}")
    print(f"Completeness: {result['completeness']:.4f}")
    print(f"Number of angles: {len(result['angles'])}")



#modify "the paramter in the function is a list, for our purposes, this is a list that updates as the specific angles change,
#test_angles = list(range(0, 360, 90))  # Use every X degrees
#debugging area

solvedAngles = [0, 180, 195, 200, 30, 220, 190, 170, 10, 215, 185, 40, 245, 135, 280, 100, 320, 80, 165, 5, 35, 330, 210, 60, 295, 340, 120, 270, 145, 235, 75, 255, 305, 90, 275, 105, 335, 300, 25, 350, 325, 175, 355, 240, 65, 155, 50, 115, 310, 70, 160, 225, 45, 250, 315, 285, 110, 20, 55, 95, 345, 130, 260, 140, 265, 15, 230, 85, 125, 290
]


# test_angles = list(range(0, 355, 5))  # Use every C degrees between A and B
test_angles  = [0, 90, 180, 270]


mean_error, std_error = anglesToImgQualityDEBUG.anglesToImgQuality(test_angles)  #can be suppressed to remove text outputs, rn for debugging
print(f"Test Results: Mean Error = {mean_error:.4f}, Std Error = {std_error:.4f}")

completeness = anglesToCompleteness(test_angles)
print(f"Test Results: Completeness = {completeness:.4f}")

#modify "the paramter in the function is a list, for our purposes, this is a list that updates as the specific angles change,
#test_angles = list(range(0, 360, 90))  # Use every X degrees
#debugging area

solvedAngles = [0, 180, 195, 200, 30, 220, 190, 170, 10, 215, 185, 40, 245, 135, 280, 100, 320, 80, 165, 5, 35, 330, 210, 60, 295, 340, 120, 270, 145, 235, 75, 255, 305, 90, 275, 105, 335, 300, 25, 350, 325, 175, 355, 240, 65, 155, 50, 115, 310, 70, 160, 225, 45, 250, 315, 285, 110, 20, 55, 95, 345, 130, 260, 140, 265, 15, 230, 85, 125, 290
]


# test_angles = list(range(0, 355, 5))  # Use every C degrees between A and B
test_angles  = solvedAngles


mean_error, std_error = anglesToImgQuality.anglesToImgQuality(test_angles)  #can be suppressed to remove text outputs, rn for debugging
print(f"Test Results: Mean Error = {mean_error:.4f}, Std Error = {std_error:.4f}")

completeness = anglesToCompleteness(test_angles)
print(f"Test Results: Completeness = {completeness:.4f}")